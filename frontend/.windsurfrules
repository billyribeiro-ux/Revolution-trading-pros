# Windsurf AI Rules - Revolution Trading Pros v2
## Apple Principal Engineer ICT Level 7 Standards | January 2026

---

## üéØ PRIME DIRECTIVE

**Before ANY code modification, you MUST:**

1. **READ and UNDERSTAND** the entire file being modified
2. **TRACE all imports, exports, and dependencies** to understand the full context
3. **IDENTIFY the function's purpose** within the page/component hierarchy
4. **MAP state flow** - where does data come from? Where does it go?
5. **CHECK for related files** - tests, types, stores, utilities
6. **UNDERSTAND the business logic** - what is this feature trying to accomplish?

**NEVER make changes without full context. Ask if unclear.**

---

## üì¶ Technology Stack Reference

### Frontend
- **Framework:** SvelteKit 2.50.1 + Svelte 5.48.2
- **Styling:** Tailwind CSS v4.1.18 (NEW SYNTAX)
- **Build:** Vite 7.3.1
- **Testing:** Playwright 1.58.0 + Vitest 4.0.18
- **Deployment:** Cloudflare Pages
- **Charts:** Lightweight Charts, D3.js
- **3D:** Three.js + Threlte
- **Validation:** Zod v4
- **Animation:** GSAP 3.14.2, Lottie, Vivus

### Backend
- **Language:** Rust 2021 Edition
- **Framework:** Axum 0.7 + Tower
- **Runtime:** Tokio 1.35
- **Database:** PostgreSQL (SQLx 0.8)
- **Cache:** Redis/Upstash
- **Storage:** Cloudflare R2
- **Search:** Meilisearch 0.26
- **Auth:** JWT + Argon2

---

## üî• SVELTE 5 MANDATORY PATTERNS (January 2026)

### Runes - ALWAYS USE THESE

```svelte
<script lang="ts">
  // ‚úÖ CORRECT - Svelte 5 Runes
  let count = $state(0);
  let doubled = $derived(count * 2);
  let items = $state<Item[]>([]);
  
  // ‚úÖ CORRECT - Props with defaults
  let { 
    title, 
    onClose, 
    variant = 'primary' 
  }: { 
    title: string; 
    onClose: () => void; 
    variant?: 'primary' | 'secondary';
  } = $props();
  
  // ‚úÖ CORRECT - Bindable props
  let { value = $bindable() }: { value: string } = $props();
  
  // ‚úÖ CORRECT - Effects
  $effect(() => {
    console.log('Count changed:', count);
    // Cleanup function
    return () => {
      console.log('Cleanup');
    };
  });
  
  // ‚úÖ CORRECT - Untracked reads
  $effect(() => {
    const currentCount = $state.snapshot(items);
    // Use snapshot for non-reactive reads
  });
  
  // ‚ùå NEVER USE - Svelte 4 Legacy
  // export let prop;        // BANNED
  // $: derived = x * 2;     // BANNED
  // let:item                // BANNED
  // <slot />                // BANNED
</script>
```

### Snippets Replace Slots - MANDATORY

```svelte
<!-- ‚úÖ CORRECT - Svelte 5 Snippets -->
<script lang="ts">
  import type { Snippet } from 'svelte';
  
  let { 
    children,
    header,
    footer 
  }: { 
    children: Snippet;
    header?: Snippet;
    footer?: Snippet<[{ count: number }]>;
  } = $props();
</script>

{#if header}
  {@render header()}
{/if}

{@render children()}

{#if footer}
  {@render footer({ count: 42 })}
{/if}

<!-- Usage -->
<MyComponent>
  {#snippet header()}
    <h1>Title</h1>
  {/snippet}
  
  <p>Main content (children)</p>
  
  {#snippet footer(data)}
    <span>Count: {data.count}</span>
  {/snippet}
</MyComponent>

<!-- ‚ùå NEVER USE -->
<!-- <slot />                    BANNED -->
<!-- <slot name="header" />      BANNED -->
<!-- let:item                    BANNED -->
```

### Event Handlers - Svelte 5 Style

```svelte
<!-- ‚úÖ CORRECT - Svelte 5 -->
<button onclick={handleClick}>Click</button>
<input oninput={(e) => value = e.currentTarget.value} />
<form onsubmit={handleSubmit}>

<!-- ‚ùå NEVER USE - Svelte 4 -->
<!-- on:click={handler}     BANNED -->
<!-- on:input={handler}     BANNED -->
<!-- on:submit|preventDefault  BANNED -->
```

### Component Events - Callback Props

```svelte
<!-- ‚úÖ CORRECT - Svelte 5 callback props -->
<script lang="ts">
  let { 
    onSelect,
    onChange,
    onClose 
  }: { 
    onSelect?: (item: Item) => void;
    onChange?: (value: string) => void;
    onClose?: () => void;
  } = $props();
  
  function handleSelect(item: Item) {
    onSelect?.(item);
  }
</script>

<!-- ‚ùå NEVER USE createEventDispatcher -->
<!-- import { createEventDispatcher } from 'svelte';  BANNED -->
<!-- dispatch('select', item);                         BANNED -->
```

### Stores in Svelte 5

```svelte
<script lang="ts">
  import { userStore } from '$lib/stores/user.svelte';
  
  // ‚úÖ CORRECT - Direct access (stores are reactive by default)
  // userStore.value is reactive
  
  // For writable stores in .svelte.ts files:
  // export const count = $state(0);
</script>

<!-- ‚ùå NEVER USE $ prefix for store subscription -->
<!-- {$userStore}  - Only use if absolutely necessary -->
```

---

## üé® TAILWIND CSS v4.1.18 - NEW SYNTAX (January 2026)

### Configuration - CSS-First Approach

```css
/* app.css - Tailwind v4 configuration */
@import "tailwindcss";

/* Theme customization */
@theme {
  /* Colors */
  --color-brand-primary: #3b82f6;
  --color-brand-secondary: #10b981;
  --color-surface-dark: #0f0f0f;
  --color-surface-card: #1a1a1a;
  --color-surface-elevated: #262626;
  
  /* Typography */
  --font-sans: 'Inter', system-ui, sans-serif;
  --font-mono: 'JetBrains Mono', monospace;
  
  /* Spacing */
  --spacing-container: clamp(1rem, 5vw, 3rem);
  
  /* Animations */
  --ease-spring: cubic-bezier(0.175, 0.885, 0.32, 1.275);
  --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
  
  /* Shadows */
  --shadow-card: 0 4px 6px -1px rgb(0 0 0 / 0.3);
  --shadow-elevated: 0 20px 25px -5px rgb(0 0 0 / 0.4);
}

/* Dark mode variants */
@variant dark (&:where(.dark, .dark *));

/* Custom utilities */
@utility scrollbar-hide {
  -ms-overflow-style: none;
  scrollbar-width: none;
  &::-webkit-scrollbar {
    display: none;
  }
}

@utility text-balance {
  text-wrap: balance;
}

/* Container queries */
@utility container-sm {
  container-type: inline-size;
  container-name: card;
}
```

### Usage in Components

```svelte
<!-- ‚úÖ CORRECT - Tailwind v4 -->
<div class="
  bg-surface-card 
  text-white/90
  rounded-2xl 
  p-6
  shadow-card
  hover:shadow-elevated
  transition-shadow
  duration-300
  ease-smooth
">
  <h2 class="text-xl font-semibold text-balance">Title</h2>
</div>

<!-- Container queries -->
<div class="container-sm">
  <div class="@sm:flex @md:grid @md:grid-cols-2">
    <!-- Responsive based on container, not viewport -->
  </div>
</div>
```

---

## üé¨ NETFLIX-GRADE UI/UX ANIMATIONS

### GSAP Integration Pattern

```svelte
<script lang="ts">
  import { gsap } from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';
  
  gsap.registerPlugin(ScrollTrigger);
  
  let container: HTMLElement;
  let cards: HTMLElement[] = $state([]);
  
  $effect(() => {
    if (!container) return;
    
    // Staggered card entrance
    const ctx = gsap.context(() => {
      gsap.from(cards, {
        y: 100,
        opacity: 0,
        duration: 0.8,
        stagger: 0.1,
        ease: 'power3.out',
        scrollTrigger: {
          trigger: container,
          start: 'top 80%',
          toggleActions: 'play none none reverse'
        }
      });
    }, container);
    
    return () => ctx.revert();
  });
</script>

<div bind:this={container} class="grid grid-cols-4 gap-6">
  {#each items as item, i}
    <div bind:this={cards[i]} class="card">
      <!-- Content -->
    </div>
  {/each}
</div>
```

### Netflix Card Hover Effect

```svelte
<script lang="ts">
  import { gsap } from 'gsap';
  
  let card: HTMLElement;
  let isHovered = $state(false);
  
  function handleMouseEnter() {
    isHovered = true;
    gsap.to(card, {
      scale: 1.05,
      y: -10,
      boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)',
      duration: 0.3,
      ease: 'power2.out'
    });
  }
  
  function handleMouseLeave() {
    isHovered = false;
    gsap.to(card, {
      scale: 1,
      y: 0,
      boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
      duration: 0.3,
      ease: 'power2.out'
    });
  }
</script>

<div
  bind:this={card}
  class="
    relative 
    rounded-xl 
    overflow-hidden 
    cursor-pointer
    transform-gpu
    will-change-transform
  "
  onmouseenter={handleMouseEnter}
  onmouseleave={handleMouseLeave}
>
  <img 
    src={thumbnail} 
    alt={title}
    class="w-full aspect-video object-cover"
    loading="lazy"
  />
  
  {#if isHovered}
    <div 
      class="
        absolute inset-0 
        bg-gradient-to-t from-black/90 via-black/50 to-transparent
        flex flex-col justify-end
        p-4
      "
    >
      <h3 class="text-lg font-bold">{title}</h3>
      <p class="text-sm text-white/70 line-clamp-2">{description}</p>
    </div>
  {/if}
</div>
```

### Page Transitions

```svelte
<!-- +layout.svelte -->
<script lang="ts">
  import { page } from '$app/stores';
  import { gsap } from 'gsap';
  
  let { children } = $props();
  let container: HTMLElement;
  
  $effect(() => {
    // Track page changes
    const currentPath = $page.url.pathname;
    
    gsap.fromTo(
      container,
      { opacity: 0, y: 20 },
      { opacity: 1, y: 0, duration: 0.4, ease: 'power2.out' }
    );
  });
</script>

<div bind:this={container}>
  {@render children()}
</div>
```

### Skeleton Loading States

```svelte
<script lang="ts">
  let { isLoading = false }: { isLoading?: boolean } = $props();
</script>

{#if isLoading}
  <div class="animate-pulse space-y-4">
    <div class="h-48 bg-surface-elevated rounded-xl"></div>
    <div class="h-4 bg-surface-elevated rounded w-3/4"></div>
    <div class="h-4 bg-surface-elevated rounded w-1/2"></div>
  </div>
{:else}
  {@render children()}
{/if}
```

---

## üìê SVELTEKIT 2.x PATTERNS

### Load Functions - Type-Safe

```typescript
// +page.ts
import type { PageLoad } from './$types';
import { error, redirect } from '@sveltejs/kit';

export const load: PageLoad = async ({ params, fetch, parent }) => {
  // Always await parent data if needed
  const parentData = await parent();
  
  const response = await fetch(`/api/items/${params.id}`);
  
  if (!response.ok) {
    if (response.status === 404) {
      throw error(404, { message: 'Item not found' });
    }
    throw error(500, { message: 'Failed to load item' });
  }
  
  const item = await response.json();
  
  return {
    item,
    meta: {
      title: item.name,
      description: item.description
    }
  };
};
```

### Form Actions - Type-Safe

```typescript
// +page.server.ts
import type { Actions, PageServerLoad } from './$types';
import { fail, redirect } from '@sveltejs/kit';
import { z } from 'zod';

const CreateItemSchema = z.object({
  name: z.string().min(1).max(100),
  price: z.coerce.number().positive(),
  description: z.string().optional()
});

export const actions: Actions = {
  create: async ({ request, locals }) => {
    const formData = await request.formData();
    const data = Object.fromEntries(formData);
    
    const result = CreateItemSchema.safeParse(data);
    
    if (!result.success) {
      return fail(400, {
        errors: result.error.flatten().fieldErrors,
        values: data
      });
    }
    
    try {
      const item = await locals.api.createItem(result.data);
      throw redirect(303, `/items/${item.id}`);
    } catch (e) {
      return fail(500, { 
        message: 'Failed to create item',
        values: data 
      });
    }
  }
};
```

### API Routes - RESTful

```typescript
// +server.ts
import type { RequestHandler } from './$types';
import { json, error } from '@sveltejs/kit';
import { z } from 'zod';

export const GET: RequestHandler = async ({ url, locals }) => {
  const page = Number(url.searchParams.get('page')) || 1;
  const limit = Math.min(Number(url.searchParams.get('limit')) || 20, 100);
  
  const items = await locals.api.getItems({ page, limit });
  
  return json({
    items,
    pagination: {
      page,
      limit,
      total: items.total
    }
  });
};

export const POST: RequestHandler = async ({ request, locals }) => {
  const body = await request.json();
  
  // Validate with Zod
  const schema = z.object({
    name: z.string(),
    value: z.number()
  });
  
  const result = schema.safeParse(body);
  
  if (!result.success) {
    throw error(400, { message: 'Invalid request body' });
  }
  
  const item = await locals.api.createItem(result.data);
  
  return json(item, { status: 201 });
};
```

### Hooks - Auth & Error Handling

```typescript
// hooks.server.ts
import type { Handle, HandleServerError } from '@sveltejs/kit';
import { sequence } from '@sveltejs/kit/hooks';

const auth: Handle = async ({ event, resolve }) => {
  const token = event.cookies.get('auth_token');
  
  if (token) {
    try {
      const user = await verifyToken(token);
      event.locals.user = user;
    } catch {
      event.cookies.delete('auth_token', { path: '/' });
    }
  }
  
  return resolve(event);
};

const logging: Handle = async ({ event, resolve }) => {
  const start = performance.now();
  const response = await resolve(event);
  const duration = performance.now() - start;
  
  console.log(`${event.request.method} ${event.url.pathname} - ${duration.toFixed(2)}ms`);
  
  return response;
};

export const handle = sequence(auth, logging);

export const handleError: HandleServerError = async ({ error, event }) => {
  console.error('Server error:', error);
  
  return {
    message: 'An unexpected error occurred',
    code: 'INTERNAL_ERROR'
  };
};
```

---

## ü¶Ä RUST/AXUM PATTERNS

### Handler Structure

```rust
use axum::{
    extract::{Path, Query, State, Json},
    http::StatusCode,
    response::IntoResponse,
};
use serde::{Deserialize, Serialize};
use validator::Validate;

#[derive(Debug, Deserialize, Validate)]
pub struct CreateItemRequest {
    #[validate(length(min = 1, max = 100))]
    name: String,
    
    #[validate(range(min = 0.01))]
    price: f64,
    
    #[validate(length(max = 1000))]
    description: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ItemResponse {
    id: uuid::Uuid,
    name: String,
    price: f64,
    created_at: chrono::DateTime<chrono::Utc>,
}

pub async fn create_item(
    State(state): State<AppState>,
    Json(payload): Json<CreateItemRequest>,
) -> Result<impl IntoResponse, AppError> {
    payload.validate()?;
    
    let item = state.db.create_item(&payload).await?;
    
    Ok((StatusCode::CREATED, Json(ItemResponse::from(item))))
}

pub async fn get_item(
    State(state): State<AppState>,
    Path(id): Path<uuid::Uuid>,
) -> Result<impl IntoResponse, AppError> {
    let item = state.db
        .get_item(id)
        .await?
        .ok_or(AppError::NotFound)?;
    
    Ok(Json(ItemResponse::from(item)))
}
```

### Error Handling

```rust
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;

#[derive(Debug)]
pub enum AppError {
    NotFound,
    Unauthorized,
    Forbidden,
    BadRequest(String),
    Internal(anyhow::Error),
    Validation(validator::ValidationErrors),
    Database(sqlx::Error),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            AppError::NotFound => (StatusCode::NOT_FOUND, "Resource not found".to_string()),
            AppError::Unauthorized => (StatusCode::UNAUTHORIZED, "Unauthorized".to_string()),
            AppError::Forbidden => (StatusCode::FORBIDDEN, "Forbidden".to_string()),
            AppError::BadRequest(msg) => (StatusCode::BAD_REQUEST, msg),
            AppError::Internal(e) => {
                tracing::error!("Internal error: {:?}", e);
                (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error".to_string())
            }
            AppError::Validation(e) => (StatusCode::BAD_REQUEST, format!("{}", e)),
            AppError::Database(e) => {
                tracing::error!("Database error: {:?}", e);
                (StatusCode::INTERNAL_SERVER_ERROR, "Database error".to_string())
            }
        };

        (status, Json(json!({ "error": message }))).into_response()
    }
}

impl From<sqlx::Error> for AppError {
    fn from(e: sqlx::Error) -> Self {
        AppError::Database(e)
    }
}

impl From<validator::ValidationErrors> for AppError {
    fn from(e: validator::ValidationErrors) -> Self {
        AppError::Validation(e)
    }
}
```

### Database Queries - SQLx

```rust
use sqlx::{PgPool, FromRow};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, FromRow)]
pub struct Item {
    pub id: Uuid,
    pub name: String,
    pub price: rust_decimal::Decimal,
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

impl ItemRepository {
    pub async fn create(&self, req: &CreateItemRequest) -> Result<Item, sqlx::Error> {
        sqlx::query_as!(
            Item,
            r#"
            INSERT INTO items (name, price, description)
            VALUES ($1, $2, $3)
            RETURNING id, name, price, description, created_at, updated_at
            "#,
            req.name,
            rust_decimal::Decimal::from_f64_retain(req.price).unwrap(),
            req.description
        )
        .fetch_one(&self.pool)
        .await
    }
    
    pub async fn get_by_id(&self, id: Uuid) -> Result<Option<Item>, sqlx::Error> {
        sqlx::query_as!(
            Item,
            r#"
            SELECT id, name, price, description, created_at, updated_at
            FROM items
            WHERE id = $1 AND deleted_at IS NULL
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await
    }
    
    pub async fn list(
        &self,
        page: i64,
        limit: i64,
    ) -> Result<(Vec<Item>, i64), sqlx::Error> {
        let offset = (page - 1) * limit;
        
        let items = sqlx::query_as!(
            Item,
            r#"
            SELECT id, name, price, description, created_at, updated_at
            FROM items
            WHERE deleted_at IS NULL
            ORDER BY created_at DESC
            LIMIT $1 OFFSET $2
            "#,
            limit,
            offset
        )
        .fetch_all(&self.pool)
        .await?;
        
        let total: (i64,) = sqlx::query_as(
            "SELECT COUNT(*) FROM items WHERE deleted_at IS NULL"
        )
        .fetch_one(&self.pool)
        .await?;
        
        Ok((items, total.0))
    }
}
```

---

## ‚úÖ TESTING REQUIREMENTS

### Unit Tests - Vitest

```typescript
// component.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/svelte';
import Button from './Button.svelte';

describe('Button', () => {
  it('renders with correct text', () => {
    render(Button, { props: { children: () => 'Click me' } });
    expect(screen.getByRole('button')).toHaveTextContent('Click me');
  });
  
  it('calls onClick when clicked', async () => {
    const onClick = vi.fn();
    render(Button, { props: { onClick } });
    
    await fireEvent.click(screen.getByRole('button'));
    
    expect(onClick).toHaveBeenCalledOnce();
  });
  
  it('is disabled when loading', () => {
    render(Button, { props: { isLoading: true } });
    expect(screen.getByRole('button')).toBeDisabled();
  });
});
```

### E2E Tests - Playwright

```typescript
// tests/auth.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Authentication', () => {
  test('user can log in', async ({ page }) => {
    await page.goto('/login');
    
    await page.getByLabel('Email').fill('test@example.com');
    await page.getByLabel('Password').fill('password123');
    await page.getByRole('button', { name: 'Sign In' }).click();
    
    await expect(page).toHaveURL('/dashboard');
    await expect(page.getByText('Welcome back')).toBeVisible();
  });
  
  test('shows error for invalid credentials', async ({ page }) => {
    await page.goto('/login');
    
    await page.getByLabel('Email').fill('wrong@example.com');
    await page.getByLabel('Password').fill('wrongpassword');
    await page.getByRole('button', { name: 'Sign In' }).click();
    
    await expect(page.getByText('Invalid credentials')).toBeVisible();
    await expect(page).toHaveURL('/login');
  });
});
```

### Rust Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum_test::TestServer;
    
    async fn setup() -> TestServer {
        let app = create_app().await;
        TestServer::new(app).unwrap()
    }
    
    #[tokio::test]
    async fn test_create_item() {
        let server = setup().await;
        
        let response = server
            .post("/api/items")
            .json(&json!({
                "name": "Test Item",
                "price": 29.99
            }))
            .await;
        
        response.assert_status_created();
        
        let body: ItemResponse = response.json();
        assert_eq!(body.name, "Test Item");
    }
    
    #[tokio::test]
    async fn test_get_nonexistent_item() {
        let server = setup().await;
        
        let response = server
            .get(&format!("/api/items/{}", Uuid::new_v4()))
            .await;
        
        response.assert_status_not_found();
    }
}
```

---

## üö® CODE QUALITY ENFORCEMENT

### TypeScript Strict Mode - MANDATORY

```json
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true
  }
}
```

### ESLint Rules - Svelte 5

```javascript
// eslint.config.js
import svelte from 'eslint-plugin-svelte';

export default [
  ...svelte.configs['flat/recommended'],
  {
    rules: {
      'svelte/no-unused-svelte-ignore': 'error',
      'svelte/valid-compile': 'error',
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/explicit-function-return-type': 'warn',
      'no-console': ['warn', { allow: ['warn', 'error'] }]
    }
  }
];
```

---

## üìã PRE-COMMIT CHECKLIST

Before submitting ANY code change:

- [ ] **Full file context understood** - Read the entire file
- [ ] **Dependencies traced** - Know what imports/exports affect
- [ ] **Types are correct** - No `any`, all interfaces defined
- [ ] **Svelte 5 syntax** - Runes, snippets, callback props only
- [ ] **Tailwind v4 syntax** - @theme, @utility, modern classes
- [ ] **Tests written/updated** - Unit + E2E coverage
- [ ] **Animations smooth** - 60fps, GPU-accelerated
- [ ] **Accessibility checked** - ARIA labels, keyboard navigation
- [ ] **Error states handled** - Loading, error, empty states
- [ ] **Mobile responsive** - Tested on all breakpoints
- [ ] **No TypeScript errors** - `svelte-check` passes
- [ ] **No ESLint errors** - All rules satisfied
- [ ] **Related files updated** - Types, tests, stories

---

## üéØ COMPONENT ARCHITECTURE

### File Structure

```
src/lib/components/
‚îú‚îÄ‚îÄ ui/                    # Primitive UI components
‚îÇ   ‚îú‚îÄ‚îÄ Button/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.svelte
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.stories.svelte
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ features/              # Feature-specific components
‚îÇ   ‚îú‚îÄ‚îÄ trading/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Chart/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderBook/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ layout/               # Layout components
    ‚îú‚îÄ‚îÄ Header/
    ‚îú‚îÄ‚îÄ Sidebar/
    ‚îî‚îÄ‚îÄ ...
```

### Component Template

```svelte
<!--
  @component ComponentName
  @description Brief description of what this component does
  
  @example
  ```svelte
  <ComponentName title="Hello" onSelect={handleSelect} />
  ```
-->
<script lang="ts">
  import type { Snippet } from 'svelte';
  
  // Types
  interface Props {
    /** The title to display */
    title: string;
    /** Called when an item is selected */
    onSelect?: (id: string) => void;
    /** Optional children content */
    children?: Snippet;
  }
  
  // Props
  let { 
    title,
    onSelect,
    children
  }: Props = $props();
  
  // State
  let isOpen = $state(false);
  
  // Derived
  let displayTitle = $derived(title.toUpperCase());
  
  // Effects
  $effect(() => {
    // Setup
    return () => {
      // Cleanup
    };
  });
  
  // Handlers
  function handleClick() {
    isOpen = !isOpen;
    onSelect?.(title);
  }
</script>

<div class="component-root">
  <button onclick={handleClick}>
    {displayTitle}
  </button>
  
  {#if isOpen && children}
    {@render children()}
  {/if}
</div>

<style>
  /* Component-scoped styles if needed */
</style>
```

---

## üîí SECURITY REQUIREMENTS

### Input Validation - Always Use Zod

```typescript
import { z } from 'zod';

// Define schemas
export const UserSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8).max(100),
  name: z.string().min(1).max(100).optional()
});

// Use in form actions
const result = UserSchema.safeParse(formData);
if (!result.success) {
  return fail(400, { errors: result.error.flatten() });
}
```

### XSS Prevention

```svelte
<script lang="ts">
  import DOMPurify from 'isomorphic-dompurify';
  
  let { htmlContent }: { htmlContent: string } = $props();
  
  let sanitized = $derived(DOMPurify.sanitize(htmlContent));
</script>

<!-- Safe HTML rendering -->
{@html sanitized}
```

### CSRF Protection

```typescript
// hooks.server.ts
import { dev } from '$app/environment';

export const handle: Handle = async ({ event, resolve }) => {
  // Verify CSRF for mutations
  if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(event.request.method)) {
    const origin = event.request.headers.get('origin');
    const host = event.request.headers.get('host');
    
    if (!dev && origin !== `https://${host}`) {
      return new Response('CSRF validation failed', { status: 403 });
    }
  }
  
  return resolve(event);
};
```

---

## üì± RESPONSIVE DESIGN

### Breakpoint Strategy

```css
/* Tailwind v4 breakpoints */
@theme {
  --breakpoint-sm: 640px;
  --breakpoint-md: 768px;
  --breakpoint-lg: 1024px;
  --breakpoint-xl: 1280px;
  --breakpoint-2xl: 1536px;
}
```

### Mobile-First Components

```svelte
<div class="
  /* Mobile (default) */
  flex flex-col gap-4 p-4
  
  /* Tablet */
  md:flex-row md:gap-6 md:p-6
  
  /* Desktop */
  lg:gap-8 lg:p-8
  
  /* Large Desktop */
  xl:max-w-7xl xl:mx-auto
">
  <!-- Content -->
</div>
```

---

## üîÑ STATE MANAGEMENT

### Global Stores - .svelte.ts Pattern

```typescript
// stores/user.svelte.ts
import type { User } from '$lib/types';

class UserStore {
  user = $state<User | null>(null);
  isLoading = $state(false);
  
  isAuthenticated = $derived(this.user !== null);
  
  async login(email: string, password: string) {
    this.isLoading = true;
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        body: JSON.stringify({ email, password })
      });
      this.user = await response.json();
    } finally {
      this.isLoading = false;
    }
  }
  
  logout() {
    this.user = null;
  }
}

export const userStore = new UserStore();
```

### Context for Component Trees

```svelte
<!-- Parent.svelte -->
<script lang="ts">
  import { setContext } from 'svelte';
  
  const theme = $state({ mode: 'dark' });
  setContext('theme', theme);
</script>

<!-- Child.svelte -->
<script lang="ts">
  import { getContext } from 'svelte';
  
  const theme = getContext<{ mode: string }>('theme');
</script>
```

---

## üìä PERFORMANCE OPTIMIZATION

### Image Optimization

```svelte
<script lang="ts">
  import { decode } from 'blurhash';
  
  let { src, alt, blurhash }: Props = $props();
  let isLoaded = $state(false);
</script>

<div class="relative aspect-video">
  {#if !isLoaded && blurhash}
    <canvas 
      class="absolute inset-0 w-full h-full"
      use:renderBlurhash={blurhash}
    />
  {/if}
  
  <img
    {src}
    {alt}
    loading="lazy"
    decoding="async"
    onload={() => isLoaded = true}
    class="w-full h-full object-cover transition-opacity duration-300"
    class:opacity-0={!isLoaded}
  />
</div>
```

### Code Splitting

```typescript
// Lazy load heavy components
const Chart = await import('$lib/components/Chart.svelte');

// Dynamic imports in routes
export const load = async () => {
  const data = await import('./heavy-data.json');
  return { data: data.default };
};
```

### Memoization

```svelte
<script lang="ts">
  let items = $state<Item[]>([]);
  let filter = $state('');
  
  // Expensive computation is cached
  let filteredItems = $derived.by(() => {
    console.log('Filtering...'); // Only runs when items or filter changes
    return items.filter(item => 
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
  });
</script>
```

---

## üéØ ACCESSIBILITY (A11Y)

### Required Patterns

```svelte
<!-- Buttons -->
<button
  type="button"
  aria-label="Close dialog"
  aria-pressed={isPressed}
  disabled={isLoading}
>
  <span class="sr-only">Close</span>
  <XIcon aria-hidden="true" />
</button>

<!-- Forms -->
<label for="email">Email</label>
<input 
  id="email" 
  type="email"
  aria-describedby="email-error"
  aria-invalid={hasError}
/>
{#if hasError}
  <p id="email-error" role="alert">Please enter a valid email</p>
{/if}

<!-- Modals -->
<div
  role="dialog"
  aria-modal="true"
  aria-labelledby="modal-title"
>
  <h2 id="modal-title">Modal Title</h2>
</div>

<!-- Live Regions -->
<div aria-live="polite" aria-atomic="true">
  {statusMessage}
</div>
```

### Focus Management

```svelte
<script lang="ts">
  let dialogRef: HTMLElement;
  let triggerRef: HTMLElement;
  
  $effect(() => {
    if (isOpen) {
      // Focus first focusable element
      dialogRef?.querySelector<HTMLElement>('[autofocus]')?.focus();
    } else {
      // Return focus to trigger
      triggerRef?.focus();
    }
  });
</script>
```

---

## üìù DOCUMENTATION REQUIREMENTS

### JSDoc for All Exports

```typescript
/**
 * Formats a currency value with the specified locale and currency code.
 * 
 * @param value - The numeric value to format
 * @param currency - ISO 4217 currency code (default: 'USD')
 * @param locale - BCP 47 locale string (default: 'en-US')
 * @returns Formatted currency string
 * 
 * @example
 * ```ts
 * formatCurrency(1234.56) // '$1,234.56'
 * formatCurrency(1234.56, 'EUR', 'de-DE') // '1.234,56 ‚Ç¨'
 * ```
 */
export function formatCurrency(
  value: number,
  currency: string = 'USD',
  locale: string = 'en-US'
): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency
  }).format(value);
}
```

---

## ‚ö° REMEMBER

1. **Context First** - ALWAYS read and understand before changing
2. **Svelte 5 Only** - Runes, snippets, callback props, no legacy syntax
3. **Tailwind v4** - @theme, @utility, modern classes
4. **Type Safety** - No `any`, strict mode, Zod validation
5. **Test Everything** - Unit, E2E, edge cases
6. **Netflix Quality** - 60fps animations, skeleton states, polish
7. **Apply Everywhere** - Changes must propagate to all affected files
8. **End-to-End** - Verify the full user flow works

---

*Last Updated: January 2026*
*Stack: SvelteKit 2.50.1 | Svelte 5.48.2 | Tailwind v4.1.18 | Rust/Axum 0.7*