<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Backlink;
use Illuminate\Http\Request;

class BacklinkController extends Controller
{
    /**
     * Get backlink profile.
     */
    public function index()
    {
        $backlinks = Backlink::all();

        $profile = [
            'total_backlinks' => $backlinks->count(),
            'total_domains' => $backlinks->pluck('source_url')->unique()->count(),
            'follow_backlinks' => $backlinks->where('is_follow', true)->count(),
            'nofollow_backlinks' => $backlinks->where('is_follow', false)->count(),
            'toxic_backlinks' => $backlinks->where('is_toxic', true)->count(),
            'average_domain_authority' => $backlinks->avg('domain_authority'),
            'backlinks' => $backlinks->take(100),
        ];

        return response()->json(['profile' => $profile]);
    }

    /**
     * Get new backlinks.
     */
    public function new()
    {
        $backlinks = Backlink::where('first_seen_at', '>=', now()->subDays(7))
            ->orderBy('first_seen_at', 'desc')
            ->get();

        return response()->json(['backlinks' => $backlinks]);
    }

    /**
     * Get toxic backlinks.
     */
    public function toxic()
    {
        $backlinks = Backlink::where('is_toxic', true)->get();

        return response()->json(['toxic' => $backlinks]);
    }

    /**
     * Disavow backlinks by generating a Google Search Console compatible disavow file.
     * Format follows Google's specification: https://support.google.com/webmasters/answer/2648487
     */
    public function disavow(Request $request)
    {
        $request->validate([
            'domains' => 'required|array|min:1',
            'domains.*' => 'string|max:255',
            'format' => 'nullable|in:txt,json',
            'include_urls' => 'nullable|boolean',
        ]);

        $domains = array_unique(array_filter($request->domains));
        $format = $request->input('format', 'txt');
        $includeUrls = $request->boolean('include_urls', false);

        // Mark backlinks from these domains as disavowed in database
        $disavowedCount = 0;
        foreach ($domains as $domain) {
            $domain = $this->normalizeDomain($domain);
            $updated = Backlink::where('source_url', 'like', "%{$domain}%")
                ->update([
                    'is_disavowed' => true,
                    'disavowed_at' => now()
                ]);
            $disavowedCount += $updated;
        }

        if ($format === 'json') {
            return response()->json([
                'message' => 'Disavow list generated',
                'domains' => $domains,
                'backlinks_affected' => $disavowedCount,
                'generated_at' => now()->toIso8601String(),
            ]);
        }

        // Generate Google Search Console disavow file format
        $fileContent = "# Disavow file generated by Revolution Trading Pros\n";
        $fileContent .= "# Generated at: " . now()->toIso8601String() . "\n";
        $fileContent .= "# Total domains: " . count($domains) . "\n";
        $fileContent .= "# Backlinks affected: {$disavowedCount}\n\n";

        foreach ($domains as $domain) {
            $normalizedDomain = $this->normalizeDomain($domain);
            $fileContent .= "domain:{$normalizedDomain}\n";

            // Optionally include specific URLs from this domain
            if ($includeUrls) {
                $urls = Backlink::where('source_url', 'like', "%{$normalizedDomain}%")
                    ->where('is_disavowed', true)
                    ->pluck('source_url')
                    ->take(100);

                foreach ($urls as $url) {
                    $fileContent .= "# {$url}\n";
                }
            }
        }

        // Return as downloadable file
        return response($fileContent, 200, [
            'Content-Type' => 'text/plain',
            'Content-Disposition' => 'attachment; filename="disavow_' . date('Y-m-d') . '.txt"',
            'X-Backlinks-Affected' => $disavowedCount,
        ]);
    }

    /**
     * Normalize domain by removing protocol and www prefix.
     */
    private function normalizeDomain(string $domain): string
    {
        $domain = trim($domain);
        $domain = preg_replace('#^https?://#', '', $domain);
        $domain = preg_replace('#^www\.#', '', $domain);
        $domain = rtrim($domain, '/');

        // Extract just the domain if a full URL was provided
        if (str_contains($domain, '/')) {
            $parts = parse_url('http://' . $domain);
            $domain = $parts['host'] ?? $domain;
        }

        return strtolower($domain);
    }
}
